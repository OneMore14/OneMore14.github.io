---
layout: post
title:  "Stanford CS251 Cryptocurrencies, blockchains, and smart contracts Tips"
date:   2021-07-02 21:42:01 +0800
categories: 区块链 分布式 
typora-root-url: ../../../
---



Fall 2021  https://cs251.stanford.edu/



Tips:

## lecture1 Intro to cryptography & cryptocurrencies


![picture1](/assets/2021/07/cs251-lecture2-1.png )



CRHF = collision resistant hash function

###  binding commitment

h = Hash(message)

发送方同时给接收方message和message的哈希值h，接收方可以重新计算哈希值验证消息是否被篡改

### proof of work

![image-20220805153956093](/assets/2021/07/cs251-lecture2-2.png)



The difference between Big O notation and Big Ω notation is that Big O is used to describe the worst case running time for an algorithm. But, Big Ω notation, on the other hand, is used to describe the best case running time for a given algorithm.



比特币中满足puzzle的解就叫做nonce



### digital signatures

![image-20220805154518509](/assets/2021/07/cs251-lecture2-3.png)



## lecture2 Bitcoin nuts and bolts 



### bitcoin header

![image-20220805155126728](/assets/2021/07/cs251-lecture2-4.png)

上图中bits就是PoW的difficulty，nonce就是解， time是组装区块的时间(太久远会被reject)



### transaction structure

![image-20220805155434482](/assets/2021/07/cs251-lecture2-5.png)



![image-20220805155756948](/assets/2021/07/cs251-lecture2-6.png)



![image-20220805155940683](/assets/2021/07/cs251-lecture2-7.png)



Bitcoin script use a stack machine，not turing complete, no loops



### Tramsaction types 

无论哪种交易方式，核心思想都是将ScriptSig和ScriptPK拼接起来，然后执行

### 1. P2PKH

P2PKH = pay to public key hash， funding tx通过接收者的公钥哈希(比特币地址)来确保币的流向

ScriptPK_b = DUP HASH256 <addr_b> EQVERIFY CHECKSIG

ScriptSig_b = <sig> <pk_b>

<sig> = Sign(sk_b, Tx)    Tx = Tx_spend excluding all ScriptSigs

执行过程就是上图Example中的脚本，核心是检查b是否有对应的公钥私钥



这种转账方式有问题

![image-20220805162505696](/assets/2021/07/cs251-lecture2-8.png)

这个ECDSA malleability不是特别明白，查了一下https://wiki.bitcoinsv.io/index.php/Transaction_Malleability   ECDSA在已知(m, sig)的情况下可以构造出sig'，使得签名仍然有效，可能是在说这个问题. 

这样会使TX的TXID改变，但也仅仅是txid改变，其他都不变，交易也能正常执行。具体的场景是，如果Alice给Bob发一个BTC，并提前计算出txid(记为txid_a)后告诉了Bob，Bob可以利用这个漏洞修改txid成为txid_b，交易正常进行且Bob收到这个BTC。但Bob可以提出区块中没有txid_a这个交易，声称自己没收到钱，如果Alice一查确实没有txid_a，然后再不仔细核对的话，就可能重复给Bob发另一个BTC. 具体看下这个 https://eklitzke.org/bitcoin-transaction-malleability  





### 2. P2SH

P2SH = pay to script hash， funding tx把币转到一个脚本的哈希值，而不是公钥的哈希值

ScriptPK = HASH160 <H(redeem script)> EQUAL

ScriptSig = <sig1> <sig2> ... <sig_n> <redeem script>



可以支持multisig， 比如2-out-of-3:

<2> <PK1> <PK2> <PK3> <3> CHECKMULTISIG  只需要有任意两个sig是能验证的就好























## Lecture3 Wallets: managing and protecting crypto assets

助记词，每个单词代表11bits，一共有2048个助记词



![image-20220805204020889](/assets/2021/07/cs251-lecture3-1.png)



## Lecture4 Consensus: network models, corruption tolerance, sybil resistance

![image-20220813133754550](/assets/2021/07/cs251-lecture4-1.png)

拜占庭将军问题需要解决consistency和validity两个问题，其本身并不关心到底是attack还是retreat，只关心honest node应该行动一致。更进一步推导，leader是honest的话其他honest node就需要和leader保持一致。 也就是说，从consistency可以推导出validity，那么最核心的部分还是关注honest node的一致性。



![image-20220813134738561](/assets/2021/07/cs251-lecture4-2.png)

上图中是一种简单的投票协议，没有数字签名等验证过程，很容易证明一个corrupt leader可以造成不一致:

假设一共有$$2\times n + 1$$个节点，只有leader是corrupt，leader给其中n个节点(记为S)发的是0，给另外n个节点(记为S')发的是1，那么下一轮中S中每个节点会收到n + 1个0和n个1，最终输出0; S'中每个节点收到n + 1个1和n个0，最终输出0。这违反了一致性.



![image-20220813140416573](/assets/2021/07/cs251-lecture4-3.png)

一种加强的协议Dolev Strong Protocol可以解决BFT，但引入了电子签名，证明如下:

* **Lemma 1.** Let r ≤ f. If by the end of round r, some honest node i has $\tilde b $ in $S_i$, then by the end of round r + 1 every honest node has $\tilde b $ in its extracted set.

Lemma 1证明比较直接，如果$\tilde b $是第r轮才加入的，那么说明$\tilde b $的前r个签名都是有效的，下一轮中其他诚实节点收到$\tilde b $后会验证成功并将其加入到自己的S中。如果$\tilde b $是第r轮之前加入的，设为k，那么k+1轮的时候其他诚实节点也有$\tilde b $了.

* **Lemma 2.** If some honest node i has $\tilde b $ in $S_i$ by the end of round $f + 1$, then every honest node has $\tilde b $ in its extracted set $S$ by the end of round $f + 1$

因为如果$\tilde b $ 是在$f + 1$轮时才收到的，那么其中$f+1$个签名中至少有1个是诚实节点的签名，则此时其他诚实节点也一定会收到$\tilde b $. 如果$\tilde b $是在$f + 1$前收到的，则根据Lemma 1，其他诚实节点在$f + 1$前就已经有$\tilde b $了.  Lemma 2实际就证明了诚实节点的一致性.

Honest nodes only update set S if signed by leader. 

这个协议的弊端是要运行f +1轮，效率低。



In a blockchain we solve a Byzantine General’s Problem for every block. This is called an iterated BGP. 其实就是要对每一个区块的内容达成一致.



![image-20220813150930252](/assets/2021/07/cs251-lecture4-4.png)

上图证明需要看额外资料，先跳过.



![image-20220813153817024](/assets/2021/07/cs251-lecture4-5.png)

![image-20220813153851482](/assets/2021/07/cs251-lecture4-6.png)



一般都知道blockchain对一致性有要求，这里还提到liveness，第一次见.





















## Lecture 5. Nakamoto Consensus: security, attacks and incentives

### 

![image-20220816113837000](/assets/2021/07/cs251-lecture5-1.png)



关于Chain quality涉及到许多数学证明，留作以后再看 TODO



### Selfish mining attack

思想是挖出一个block后并不广播这个块，而是等别人挖出后再广播，这样有可能自己挖出的块最后成为最长链，而别人的block就失效。理论上有1/3算力就可以控制一半的块，49%算力就能控制96%的block











## Lecture 6. Large Scale Consensus: Availability/Finality, Randomness Beacons,VDFs

Ebb-and-Flow Protocols 跳过 TODO

Randomness beacon



VDF



### Soft/Hard fork

硬分叉: 旧节点只接收新版本block，新节点只接收新版本block，不兼容

软分叉: 旧节点可以接收新版本block，感知不到变化，但新节点只接收新block，当新节点超过50%后，整条链完成升级了，只接收新版本block













## Lecture 7: Ethereum: Decentralized Apps, EVM, and the Ethereum blockchain

world state



ETH的account分为owned accounts和contract两种，合约类似编程语言中的函数，其表达能力超过BTC的脚本语言.  合约的执行需要gas费，指令越多，gas费也越多。















## Lecture 8: Solidity

跟普通编程语言差不多，也有interface的概念，可以继承，有方法可见性











## Lecture 9: **Stablecoins and oracles**

stablecoin: 只能说看不懂...

oracle: 

uniswap: 











## Lecture 10: Decentralized exchanges

